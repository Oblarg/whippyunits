use crate::quantity_type::{
    _2, _3, _5, _A, _I, _J, _L, _M, _N, _Pi, _T, _Θ, Dimension, Quantity, Scale,
};

// Generated by proc macro - covers range -100 to 100
whippyunits_proc_macros::pow_lookup!(pow2, 2, 100, rational);

// Generated by proc macro - covers range -100 to 100
whippyunits_proc_macros::pow_lookup!(pow3, 3, 100, rational);

// Generated by proc macro - covers range -100 to 100
whippyunits_proc_macros::pow_lookup!(pow5, 5, 100, rational);

// Generated by proc macro - covers range -8 to 8 using rational approximation 355/113
whippyunits_proc_macros::pow_pi_lookup!(pow_pi, 8, rational);

// Float lookup tables for const evaluation - generated by proc macro
whippyunits_proc_macros::pow_lookup!(pow2_float, 2.0, 100, float);

whippyunits_proc_macros::pow_lookup!(pow3_float, 3.0, 100, float);

whippyunits_proc_macros::pow_lookup!(pow5_float, 5.0, 100, float);

whippyunits_proc_macros::pow_pi_lookup!(pow_pi_float, 8, float);

#[macro_export]
#[doc(hidden)]
macro_rules! define_aggregate_scale_factor_rational {
    (
        ($($aggregate_scale_factor_params:tt)*),
        ($($aggregate_scale_factor_diff_exprs:tt)*),
        ($($aggregate_scale_factor_pow_exprs:tt)*),
        ($($aggregate_scale_factor_num_exprs:tt)*),
        ($($aggregate_scale_factor_den_exprs:tt)*),
    ) => {
        #[doc(hidden)]
        pub const fn aggregate_scale_factor(
            $($aggregate_scale_factor_params)*
        ) -> (i128, i128) {
            $($aggregate_scale_factor_diff_exprs)*

            $($aggregate_scale_factor_pow_exprs)*

            reduce_rational($($aggregate_scale_factor_num_exprs)*, $($aggregate_scale_factor_den_exprs)*)
        }
    }
}

#[macro_export]
#[doc(hidden)]
macro_rules! define_aggregate_scale_factor_float {
    (
        ($($aggregate_scale_factor_params:tt)*),
        ($($aggregate_scale_factor_diff_exprs:tt)*),
        ($($aggregate_scale_factor_pow_exprs:tt)*),
        ($($aggregate_scale_factor_expr:tt)*),
    ) => {
        #[doc(hidden)]
        pub const fn aggregate_scale_factor_float(
            $($aggregate_scale_factor_params)*
        ) -> f64 {
            $($aggregate_scale_factor_diff_exprs)*

            $($aggregate_scale_factor_pow_exprs)*

            $($aggregate_scale_factor_expr)*
        }
    }
}

/// Reduce a rational number to its simplest form using bit-shift based GCD
/// Returns (reduced_numerator, reduced_denominator)
pub const fn reduce_rational(num: i128, den: i128) -> (i128, i128) {
    if den == 0 {
        return (num, 1);
    }
    if num == 0 {
        return (0, 1);
    }

    // Convert to unsigned for bit operations
    let mut num_u = num.unsigned_abs();
    let mut den_u = den.unsigned_abs();

    // Remove common factors of 2 using bit shifts
    let common_twos = (num_u | den_u).trailing_zeros();
    num_u >>= common_twos;
    den_u >>= common_twos;

    // Now both are odd, so we can use the odd-odd case of binary GCD
    while num_u != den_u {
        if num_u > den_u {
            // num_u and den_u are both odd, so (num_u - den_u) is even
            let diff = num_u - den_u;
            num_u = diff >> diff.trailing_zeros(); // Remove factors of 2
        } else {
            let diff = den_u - num_u;
            den_u = diff >> diff.trailing_zeros(); // Remove factors of 2
        }
    }

    // num_u == den_u now, and both are odd, so this is the GCD
    let gcd = num_u;

    // Divide both by the GCD to get reduced form
    let reduced_num = num / (gcd as i128);
    let reduced_den = den / (gcd as i128);

    (reduced_num, reduced_den)
}

#[macro_export]
#[doc(hidden)]
macro_rules! _define_float_rescale {
    (
        ($($float_rescale_const_params:tt)*),
        ($($float_rescale_input_type:tt)*),
        ($($float_rescale_output_type:tt)*),
        ($($float_rescale_aggregate_args:tt)*),
        $fn:ident, $T:ty,
    ) => {
        /// Rescale a quantity to a different unit of the same dimension.
        ///
        /// Rescale works robustly with type inference, and it is not necessary to explicitly specify the
        /// const generic parameters (of which there are many).  Instead, specify the target type with
        /// the [unit!](crate::unit!) macro:
        ///
        /// ```rust
        /// # #[culit::culit(whippyunits::default_declarators::literals)]
        /// # fn main() {
        /// # use whippyunits::api::rescale;
        /// # use whippyunits::unit;
        /// let distance: unit!(mm) = rescale(1.0m); // ✅ 1000.0 Quantity<mm, f64>
        /// let distance: unit!(m) = rescale(1000.0mm); // ✅ 1.0 Quantity<m, f64>
        /// // let _distance: unit!(s) = rescale(1.0m); // ❌ Compile error (dimension mismatch)
        /// // let _distance = rescale(1.0m); // ❌ Compile error (ambiguous target type)
        /// # }
        /// ```
        ///
        /// If you are in an inline context where it is not easy to specify the target type, you can use the
        /// [rescale!](crate::rescale!) macro.
        ///
        /// Addition and subtraction in whippyunits are *scale-safe* - they require that both operands
        /// have the same scale.  Accordingly, to add or subtract quantities with different scales, you
        /// must use the `rescale` function to convert one of the quantities to the scale of the other:
        ///
        /// ```rust
        /// # #[culit::culit(whippyunits::default_declarators::literals)]
        /// # fn main() {
        /// # use whippyunits::api::rescale;
        /// let distance = rescale(1.0m) + 1.0mm; // ✅ 1001.0 Quantity<mm, f64>
        /// let distance = 1.0m + rescale(1.0mm); // ✅ 1.001 Quantity<m, f64>
        /// // let _distance = 1.0m + 1.0mm; // ❌ Compile error (scale mismatch)
        /// # }
        /// ```
        ///
        /// Types other than `f64` are supported, but must use nominally-separate suffixed rescale functions
        /// to avoid type inference issues:
        ///
        /// ```rust
        /// # #[culit::culit(whippyunits::default_declarators::literals)]
        /// # fn main() {
        /// # use whippyunits::api::rescale_i32;
        /// # use whippyunits::unit;
        /// let distance: unit!(mm, i32) = rescale_i32(1m); // ✅ 1000 Quantity<mm, i32>
        /// // let _distance: unit!(mm, i32) = rescale(1.0m) // ❌ Compile error (storage type mismatch)
        /// // let _distance: unit!(mm, i32) = rescale_i32(1.0m); // ❌ Compile error (storage type mismatch)
        /// # }
        /// ```
        pub const fn $fn<
            $($float_rescale_const_params)*
        > (
            quantity: $($float_rescale_input_type)*,
        ) -> $($float_rescale_output_type)* {
            let rescale_factor = aggregate_scale_factor_float(
                $($float_rescale_aggregate_args)*
            ) as $T;
            Quantity::<Scale<_2<SCALE_P2_TO>, _3<SCALE_P3_TO>, _5<SCALE_P5_TO>, _Pi<SCALE_PI_TO>>, Dimension<_M<MASS_EXPONENT>, _L<LENGTH_EXPONENT>, _T<TIME_EXPONENT>, _I<CURRENT_EXPONENT>, _Θ<TEMPERATURE_EXPONENT>, _N<AMOUNT_EXPONENT>, _J<LUMINOSITY_EXPONENT>, _A<ANGLE_EXPONENT>>, $T>::new(
                quantity.unsafe_value * rescale_factor
            )
        }
    };
}

#[macro_export]
#[doc(hidden)]
macro_rules! _define_int_rescale {
    (
        ($($int_rescale_const_params:tt)*),
        ($($int_rescale_input_type:tt)*),
        ($($int_rescale_output_type:tt)*),
        ($($int_rescale_aggregate_args:tt)*),
        $fn:ident, $T:ty,
    ) => {
        /// Rescale a quantity to a different unit of the same dimension.
        ///
        /// Rescale works robustly with type inference, and it is not necessary to explicitly specify the
        /// const generic parameters (of which there are many).  Instead, specify the target type with
        /// the [unit!](crate::unit!) macro:
        ///
        /// ```rust
        /// # #[culit::culit(whippyunits::default_declarators::literals)]
        /// # fn main() {
        /// # use whippyunits::api::rescale;
        /// # use whippyunits::unit;
        /// let distance: unit!(mm) = rescale(1.0m); // ✅ 1000.0 Quantity<mm, f64>
        /// let distance: unit!(m) = rescale(1000.0mm); // ✅ 1.0 Quantity<m, f64>
        /// // let _distance: unit!(s) = rescale(1.0m); // ❌ Compile error (dimension mismatch)
        /// // let _distance = rescale(1.0m); // ❌ Compile error (ambiguous target type)
        /// # }
        /// ```
        ///
        /// Addition and subtraction in whippyunits are *scale-safe* - they require that both operands
        /// have the same scale.  Accordingly, to add or subtract quantities with different scales, you
        /// must use the `rescale` function to convert one of the quantities to the scale of the other:
        ///
        /// ```rust
        /// # #[culit::culit(whippyunits::default_declarators::literals)]
        /// # fn main() {
        /// # use whippyunits::api::rescale;
        /// let distance = rescale(1.0m) + 1.0mm; // ✅ 1001.0 Quantity<mm, f64>
        /// let distance = 1.0m + rescale(1.0mm); // ✅ 1.001 Quantity<m, f64>
        /// // let _distance = 1.0m + 1.0mm; // ❌ Compile error (scale mismatch)
        /// # }
        /// ```
        ///
        /// Types other than `f64` are supported, but must use nominally-separate suffixed rescale functions
        /// to avoid type inference issues:
        ///
        /// ```rust
        /// # #[culit::culit(whippyunits::default_declarators::literals)]
        /// # fn main() {
        /// # use whippyunits::api::rescale_i32;
        /// # use whippyunits::unit;
        /// let distance: unit!(mm, i32) = rescale_i32(1m); // ✅ 1000 Quantity<mm, i32>
        /// // let _distance: unit!(mm, i32) = rescale(1.0m) // ❌ Compile error (storage type mismatch)
        /// // let _distance: unit!(mm, i32) = rescale_i32(1.0m); // ❌ Compile error (storage type mismatch)
        /// # }
        /// ```
        pub const fn $fn<
            $($int_rescale_const_params)*
        > (
            quantity: $($int_rescale_input_type)*,
        ) -> $($int_rescale_output_type)* {
            let (num, den) = aggregate_scale_factor(
                $($int_rescale_aggregate_args)*
            );
            let num = num as $T;
            let den = den as $T;

            // Numerical stability: check for potential overflow on multiplication
            // If value * num would overflow, divide first; otherwise multiply first
            let result = if quantity.unsafe_value > <$T>::max_value() / num {
                // Potential overflow: divide first to reduce intermediate value
                (quantity.unsafe_value / den) * num
            } else {
                // Safe to multiply first
                (quantity.unsafe_value * num) / den
            };

            Quantity::<Scale<_2<SCALE_P2_TO>, _3<SCALE_P3_TO>, _5<SCALE_P5_TO>, _Pi<SCALE_PI_TO>>, Dimension<_M<MASS_EXPONENT>, _L<LENGTH_EXPONENT>, _T<TIME_EXPONENT>, _I<CURRENT_EXPONENT>, _Θ<TEMPERATURE_EXPONENT>, _N<AMOUNT_EXPONENT>, _J<LUMINOSITY_EXPONENT>, _A<ANGLE_EXPONENT>>, $T>::new(result)
        }
    }
}
